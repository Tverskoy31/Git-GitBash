man <команда>  подсказка по команде
touch file1.txt  создать пустой файл
rmdir <имя папки>  удалить ПУСТУЮ папку
mv <папка А>/<имя файла> <папка В>   переместить файл из папки А в папку В
mv <папка А>/<имя файла> <папка В>/<новое имя файла>   переименовать файл
cp <папка А>/* <папка В>  скопировать папку А с файлами, в папку В
rm <папка А>/<имя файла> удалить файл в папке
rm -r <папка А>      удалить папку с файлами
rm -r ./*     удалить всё из текущей папки
rm -rf     рекурсивно удаляет папки
rm -ri <папка А>   безопасное удаление (спросит да или нет)
cat <имя файла>    отобразить содержимое файла
cat <имя файла А> <имя файла В>   отобразить содержимое файлов А и В
less <имя файла А>   отобразить содержимое файла но в более удобном виде чем в cat, для выхода нажать q, есть поиск по тексту (/слово)
vi <имя файла А>   открываем вим редактор, нажать i - переходим в режим правки (появляется insert), нажать ESC чтобы выйти из режима, :w сохранили  изменения, :q выход из редактора 
grep <текст> <имя файла А>  поиск текста в файле
grep -i <текст> <имя файла А>  поиск текста в файле без учёта регистра
grep -v <текст> <имя файла А>  показать только несовпавшие строки (инверсия выдачи поиска)
grep -c <текст> <имя файла А>  подсчёт строк со вхождением
grep -R <текст> <имя папки>/ рекурсивный поиск по директории 
grep -R <текст> .  рекурсивный поиск с текущей директории
grep -Re <текст>[12] .  рекурсивный поиск с текущей директории со вхождением <текст1> либо <текст2>
find . -name <текст>  поиск по имени файла 
find . -name <*_текст>  поиск по части имени файла 
find . -name *.mp3  поиск файлов с расширением mp3
find .-type d   поиск всех папок
find .-type d -name "one*"   поиск папок которые начинаюся с one
find . -name "*one*"   поиск файлов и папок которые содержат one
find . -name "*one*" -type f  поиск только по файлам которые содержат one
find . -name "*one*" -delete   удалить найденные файлы
find . -name "*one*" -delete -print  удалить найденные файлы и показать их имена
echo "hello world" > file.txt    "hello world" добавится в файл file.txt, повторный вызов этой команды перезапишет файл полностью
echo "hello world" >> file.txt    "hello world2" добавится в файл file.txt
/// пример///
echo "hello world1" > 1file.txt
echo "hello world2" > 2file.txt
cat 1.file 2.file >> 3.file записываем данные из предыдущих 2-х команд
///конец///
cat my.file | grep File   перенаправляем вывод в греп и делаем сразу поиск
ps   список процессов в данный момент
ps x   процессы, отсоединенные от терминала
ps u   процессы пользователя
ps au   все процессы тер`минала
ps aux   все процессы
top вывести таблицу процессов, для выхода нажать q
kill <id процесса>   убить процесс по id
kill -l вывести все типы сигналов
sigterm
kill -9 <id процесса>   завершить процесс немедленно (sigkill)
ping <URL>   отсылка тестовых пакетов, по дефолту раз в секунду CTRL+C останавливает процесс
ping -c 3 <URL>   отправить только 3 тестовых пакетов, CTRL+C останавливает процесс
ping -c 3 -i 2 <URL>   отправить 3 тестовых пакетов,через 2 секунды каждый, CTRL+C останавливает процесс
ping -c 3 -a <URL>   отправить 3 тестовых пакетов,при отправке каждого пакета будет звук, CTRL+C останавливает процесс
ping -n 5 learnqa.ru > C:\Users\Evgen\Desktop\ping.txt    сохранить ping в файл
curl <URL>   послать get запрос
curl -L <URL>   послать get запрос и разрешить переход по редиректам
curl -L <URL> --verb   послать get запрос и разрешить переход по редиректам c показом доп инфы от неё
cl --data "email=test@mail.ru" --data "password=test12345"   послать post запрос с параметром почты и пароля
ssh <user@server>   доступ на удалённый сервер
ssh testuser@ssh.learnqa.ru   как пример, для выхода набрать exit
scp testuser@ssh.learnqa.ru:/home/testuser/test.txt . копирование с удалённой машины в текущую директорию пользователя
scp test.txt testuser@ssh.learnqa.ru:/home/testuser/test3.txt  копирование на удалённую машину
sed потоковый текстовый редакор 
echo 123123 | sed 's/1/5/'   замена первой строки, в ней ищем 1 и меняем на 5
echo 123123 | sed 's/1/5/2'   замена второго вхождения, ищем 1 и меняем на 5
echo 123123 | sed 's/1/i5/g'   заменить все вхождения
sed s/test/hello/ my.file   заменить подстроки в файле (sed s/текст/новый_текст/ файл)
sed "3 s/test/hello/" my.file   заменить строку по номеру (sed "номер_строки s/текст/новый_текст/" файл)
sed "s/test/hello/;s/9/h000/ " my.file   замена по двум шаблонам (sed "s/текст/новый_текст/"файл)
sed "s/test/helloworld/w new.file" my.file  запись результата в файл new.file, а my.file это исходный файл
последовательное выполнение нескольких команд sed из отдельного файла
sed -f sed_command.file my.file  запись команд из файла (файл с командами, файл)
awk   построчная работа с файлами
echo "first second" | awk '{print $2}' вывод подстроки по номеру,$0-вся строка,$1-первая подстрока,$2-вторая подстрока
cat my.file | awk '{print $1}'   если в файле 2 колонки, то выведется 1-ая
xargs    забирает данный из одного файла и передает их в качестве аргумента в другую программу  ( команда | xargs ключи команда2 )
echo a b c d e f | xargs
echo 1.file 2.file | xargs cat   данный файлов 1 и 2 станут аргументами

a="Hello world"    а переменая
echo $a вывести переменую а на экран
bash   начать новую сессию
exit завершить сессию
export b='Hello again' передать переменную в другие сессии
echo 'echo "Hello world for every bash session"' >> ~/.bashrc     в файл bashrc добавили команду echo которая стартует каждый раз с новой сессией bash
echo "A='Hello world'" >> ~/.bashrc   добавили переменную А в баш файлик
ME=$(whoami)   результат выполнения команды хуами попадёт в переменную ME
ME_IN_DIR=$(whoami)" now in "$(pwd)
echo $ME_IN_DIR  выведет 




1. Сделать папку dir_1
mkdir dir_1
# ok

 2. Зайти в папку dir_1
cd dir_1
# ok

 3. Создать папку inner_dir_1
mkdir inner_dir_1
# ok

 4. Посмотреть где ты находишься
ls -la
# ok

 5. Находясь в папке dir_1 создать пустой текстовый файл tf_1.txt
cat > tf_1.txt, затем выход из режима редактирования Ctrl+C
# можно, но не оптимально. "идеологически верный" способ создания пустого файла: touch tf_1.txt
/// приму к сведению ///

 6. Находясь в папке dir_1 через команду cat создать текстовый файл tf_2.txt со следующими строками:
- the first 1
- the second 2
- the third 3

cat > tf_2.txt
- the first 1
- the second 2
- the third 3
затем Enter и выход из режима редактирования Ctrl+C
# ok

 7. Зайти в папку inner_dir_1
cd inner_dir_1
# ok

 8. Через cat сделать текстовый файл tf_3.txt  c любыми строками
cat > tf_3.txt
шышел
мышел
пернул
вышел
затем Enter и выход из режима редактирования Ctrl+C
# ok. Но есть еще один хороший способ добавления нескольких строк в файл, который называется Here Documents.
# рекомендую ознакомиться, это может быть полезно, например, для использования cat в скриптах
///
cat <<'EOF' > file_test.txt
Priet
Medved
EOF
///
 9. Через cat добавить в текстовый файл tf_3.txt строку “the second 2”
cat >> tf_3.txt
the second 2
# можно, но не оптимально. Если нужно добавить онемного строк в файл то лучше сделать так: echo 'the second 2' >> tf_3.txt
///echo 'the second 2' >> tf_3.txt///

10. Через cat добавить в текстовый файл tf_3.txt строку “the sec 2”
the sec 2
затем Enter и выход из режима редактирования Ctrl+C
# тут Вы ошиблись в тексте, но смысл понятен. Комментарий тот же что и к предыдущему пункту
/// echo 'the sec 2' >> tf_3.txt

 11. Через cat добавить в текстовый файл tf_2.txt строку “the sec 3”
cd ../
$ cat >> tf_2.txt
the sec 3
затем Enter и выход из режима редактирования Ctrl+C
# да, но нет :) во-первых лучше использовать echo, во-вторых не нужно выходить из текущей папки.
# погуглите, пожалуйста, про абсолютные и относительные пути к файлам. очень много наших сокурсников или не знают, или не понимают что это.
# а между тем это фундаментальные основы, как мне кажется.
///echo 'the sec3' >> tf_2.txt///

 12. Через cat добавить в текстовый файл tf_3.txt строку “the SeCoNd 2”
cat >>tf_3.txt
the SeCoNd 2
затем Enter и выход из режима редактирования Ctrl+C
# да, с учетом предыдущих комментариев. Но Ваша команда не сработает ожидаемым образом, так как Вы в предыдущей команде ушли на уровень выше в цепочке каталогов.
# то есть нас просят доавить строку в файл dir_1/inner_dir_1/tf_3.txt
# а ваша команда создаст новый файл dir_1/tf_3.txt
//////echo 'the SeCoNd 2' >> tf_3.txt//////

 13. Через cat добавить в текстовый файл tf_2.txt строку “the seConD 2”
cat >> tf_2.txt
the seConD 2
затем Enter и выход из режима редактирования Ctrl+C
# ok, с учетом предыдущих комментариев
//////echo 'the SeCoNd 2' >> tf_2.txt//////

 14. Сделать текстовый файл tf_4.txt в котором будет 15 строк.
 cat > tf_.txt
1 строка
2 строка
3 строка
4 строка
5 строка
6 строка
7 строка
8 строка
9 строка
10 строка
11 строка
12 строка
13 строка
14 строка
15 строка
затем Enter и выход из режима редактирования Ctrl+C
# Это самый простой способ создания файла с 15 строками. Но мне кажется что от нас ожидают "более другого" решения задачи.
# Можно решить задачу одной командой в одну строку. Например, используя echo или printf и расширение {}
///echo -e "1 строка\n2 строка\n3 строка\n4 строка\n5 строка\n6 строка\n7 строка\n8 строка\n9 строка\n10 строка\n11 строка\n12 строка\n13 строка\n14 строка\n15 строка" > tf_4.txt///
 
15. Сделать текстовый файл tF_5.txt в котором будет 13 строк.
cat > tF_5.txt
1 строка
2 строка
3 строка
4 строка
5 строка
6 строка
7 строка
8 строка
9 строка
10 строка
11 строка
12 строка
13 строка
затем Enter и выход из режима редактирования Ctrl+C
# ок, но см. предыдущий комментарий
///echo -e "1 строка\n2 строка\n3 строка\n4 строка\n5 строка\n6 строка\n7 строка\n8 строка\n9 строка\n10 строка\n11 строка\n12 строка\n13 строка\" > tf_5.txt///

 16. Вывести список всех файлов в папке.
ls -la
# ок.

 17. Выйти из папки inner_dir_1
cd ../
# ok. Только в одном из предыдущих шагов Вы уже вышли из inner_dir_1

 18. Вывести содержимое файла tf_3.txt в терминал.
cat inner_dir_1/tf_3.txt
# ok

 19. Найти путь к файлу tf_4.txt
find -name "tf_4.txt" -print
# ok. Но по-моему опция -print тут лишняя, т.к. она используется по умолчанию.
# и еще нужно понимать что так мы получим относительный путь, а не абсолютный.
/// realpath tf_4.txt///

 20. Отчистить файл tf_4.txt от содержимого без удаления самого файла.
> inner_dir_1/tf_4.txt
# ok

 21. Найти путь к файлам у которых есть  “tf” в названии.
find . -name 'tf*'
# почти. при таком шаблоне найдутся файлы, имя которых НАЧИНАЕТСЯ с tf. Нас же прося файлы где есть tf в любом месте
/// find . -name '*tf*' ///

 22. Найти путь к файлам у которых есть  “tf” в названии и буквы в любом регистре.
find . -iname 'tf*'
# почти правильно, с учетом предыдущего комментария
/// find . -iname '*tf*' ///

 23. Найти строки в файлах где есть комбинация букв “sec” в текущей папке
grep "sec" *
# ok

 24. Найти строки в файлах где есть комбинация букв “sec” в любом регистре в текущей папке
grep -i "sec" *
# ok

 25. Найти строки в файлах где есть только комбинация букв “sec” в текущей папке
grep -w "sec" *
# не согласен. Опция -w ищет по словам, то есть она найдет строку "bla sec bla".
# от нас просят найти только строки в которых есть "sec" и ничего более.
/// grep "sec$" * ///

 26. Найти строки в файлах где есть только комбинация букв “sec” в любом регистре в текущей папке
grep -iw "sec" *
# не согласен, см. предыдущий комментарий
/// grep -i "sec$" *///

 27. Найти строки в файлах где есть комбинация букв “second” в текущей папке
grep "second" *
# ok

 28. Найти строки в файлах где есть комбинация букв “second” в любом регистре в текущей папке
grep -i "second" *
# ok

 29. Найти строки в файлах где есть комбинация букв “second” во всех папках ниже уровнем
grep -r "second"
# ok. но будут обработаны и файлы в текущей папке, что, вероятно, будет неправильным результатом

 30. Найти только путь и название файла в строках которых есть комбинация букв “second” в текущей папке
grep -ls "second" *
# ok

 31. Найти все строки во всех файлах где нет комбинации “second”
grep -rv "second"
# ok

 32. Найти только название и путь к файлам где нет комбинации “second”
grep -rvl "second"
# ok

 33. Вывести в терминал 4 последних строк любого текстового файла
cd inner_dir_1
tail -4 tF_5.txt
# ok, но можно (иногда - нужно) использовать относительный путь к файлу
/// tail -4 ~/dir_1/inner_dir_1/tF_5.txt ///
 34. Вывести в терминал 4 первые строки любого текстового файла.
head -n4 tf_3.txt
# ok

 35. Команда в одну строку. Создать папку и создать текстовый файл с содержиммым.
mkdir inner_test;echo privet_omlet > test_tekst.txt
# ok. Тут единственное к чему можно придраться (а можно и не придираться :))- у нас фактически 2 команды, а не одна.
# Идеально будет так: mkdir -p inner_test && echo privet_omlet > test_tekst.txt
/// Буду иметь ввиду, спасибо///

 36. Команда в одну строку. Переместить в любую одну папку текстовые файлы у которых в содержимом есть слово “sec”
grep -rsw "sec" >> inner_test/zapara.txt
# тут ошибка, наверное Вы просто не то написали
/// grep -rl "sec" * | xargs mv -t Pir ///

 37. Команда в одну строку. Скопировать в любую одну папку текстовые файлы у которых в содержимом есть слово “sec”
grep -lr sec | xargs cp -t inner_test
# ok

 38. Команда в одну строку. Найти все строки c “sec” во всех текстовых файлах, скопировать и вставить эти строки в один новый созданный текстовый файл.
grep -ir --line-buffered sec >> tf_777.txt
# нет, неправильно в первой части.
# Опция -i включает регистронезависимый поиск, т.е. найдутся как строки sec, так и SEс
# Опция --line-buffered  влияет на производительность, больше вроде бы ни на что
# В таком виде команда найдет во всех файлах строки 'sec' независимо от регистра, и добавит их вместе с именами файлов к содержимому файла tf_777.txt
# Нам же нужны только строки 'sec' в нижнем регистре, и имена файлов копировать не нужно.
/// grep -r -h "^sec$" > tf_777.txt ///

 39. Команда в одну строку. Удалить текстовые файлы у которых в содержимом есть слово “sec”
grep -lr sec | xargs rm
# ok, но с замечением: про вложенные папки нам не говорили, а команда их обработает.
/// grep -l sec * | xargs rm///

 40. Просто вывести в терминал строку “Good job!!”
$ echo 'Good job v 2 chasa nochi!!'
# тут вообще всё отлично :) но ночью лучше отдыхать :)
